---
title: "Being Functional in the Dysfunctional World"
---

# PRELIMINARY

Today, there exists countless new programming languages for every imaginable task. Yet, a vast majority of software development teams use decades-old object-oriented programming languages, like Python, Java, C#, or JavaScript. In simple terms, this strange situation can be attributed to the fact that language choices in the industry are driven by economic realities, instead of by technical requirements.

The IT industry, for the most part, is made up of small companies run by businessmen. While Silicon Vally giants set technical fashion trends, there are but a few of them in existence. Most IT workers all over the world are employed by smaller entities which are not even technology companies at all. These businesses are run by non-technical, conservative businessmen: technical trends inform, but do not dictate, their business decisions; profit margins do. Consequently, the IT industry behaves like a murder of crows—cacophonous, boisterous, and assertive individually, but the whole lot nevertheless flies and lands together, watching and emulating one another.

This phenomenon, at least in part, explains JavaScript's inexplicable popularity and the relative obscurity of a more capable language, such as Dart. JavaScript is an easy language to learn to use poorly on a small scale. Dart, though quite similar in look and feel to JavaScript, is a more sophisticated language designed for use by professionals on large projects. As such, it is more difficult to learn. This makes JavaScript popular with novices. Novices are cheap to hire. Profit-driven businessmen favour cheap labourers, not expensive technologists. Thus, those few who aspire to do their jobs in technically correct ways are nonetheless constrained by the financially expedient decisions, and they must cope with the unexpected, and undesired, technical consequences that arose from those business decisions.

Other than JavaScript, Python and TypeScript are two of the most popular languages in the industry, at present. Both these languages are well established with large user communities. Python is popular in data science and server implementation because of its cogent APIs for numerical computing and system programming. TypeScript is popular in web and mobile development because it is essentially JavaScript with a powerful type system. It is more likely than not that you will be required by your employer to use these languages.

In this article, I explore the functional programming style for thinking and working in Python 3 and TypeScript 4, describing not just syntactic etiquettes but semantic proprieties as well. The target audience is technologists who lead in-house software development teams that use these languages to develop custom, line-of-business applications for small- to medium-sized businesses. By "line-of-business application" I mean specifically the mission-critical software used exclusively by small number of business-expert employees whose primary concern is efficacy, not eye candy. Although these business applications are mundane, they are essential to the running of countless businesses that operate factories, warehouses, freighters, and outlets—the ordinary companies that drive global economy.

# PAST

Every undergraduate computer science (CS) student is taught two theoretical models of computation: Church's λ-calculus and Turing's a-machine. The two theories are equivalent, and they both originated in the 1930s, [long before the advent](https://en.wikipedia.org/wiki/History_of_computing_hardware) of modern digital computers. In simple terms, [λ-calculus](https://en.wikipedia.org/wiki/Lambda_calculus) models computation as a piece of data passing through a pipeline of mathematical functions, each function producing a transformed copy of its input, whereas [a-machine](https://en.wikipedia.org/wiki/Turing_machine) models computation as a piece of data transformed by a sequence of procedures, each procedure mutating the data, in place. That is, λ-calculus leaves a history trace of the computation, but a-machine does not. Procedural programming (PP) languages like FORTRAN, C, and Pascal present a high-level view of a-machine. Functional programming (FP) languages like LISP, ML, and Haskell present a high-level view of λ-calculus. But both PP and FP languages compile down to assembly, which is a low-level software representation of hardware computation. Although both FP and PP perform the same computation in hardware, FP is closer to theoretical foundations of CS but PP is closer to practical aspects of hardware. As such, FP appeals to those with a mathematical bent, while PP appeals to those with a mechanical sense.

Computing hardware, no matter how modern, can be reduced to the a-machine model. Computation performed by this type of hardware progresses by executing one by one the operations that mutate a global state. At the start of a computation, the global data is initialised, and when the computation terminates, the result is represented by the final state of the global data. This was how computers worked in the 1940s, and this is still how computers work in the 2020s.

As hardware capabilities grew over time, software complexity increased, commensurately. PP's proximity to hardware is an asset when programming in the small, but it is a liability when developing large, complex software. Object-oriented (OO) paradigm that dominates the software industry today is a better-organised PP—a more sophisticated a-machine. But the more sophisticated organisational techniques that OO offers are indispensable when programming in the large. The `class` mechanism, the central organising principle in OO, hides mutable state inside an object and exposes the object's behaviour through a set of methods. These methods, which are just procedures, are the only way for outsiders to access and mutate the object's internal state. In this way, OO allows the programmer to divide up the application's large, aggregate state into small, manageable states hidden inside individual objects, and computation progresses as the objects interact with one another and update each other's states via mutating methods.

The first OO language is Simula (1962). But it was not until the advent of C++ in the 1980s and Java in the 1990s that made OO a household name. OO's appeal is that it allows the programmer to model directly the real-life concepts and entities—banks, boats, bacteria, whatever—while remaining close to the hardware semantics. Thus, OO, like its PP cousin, appeals to the mechanically minded programmers.

Despite the perennial popularity of OO languages in industry, academic FP languages are making inroads into industry, today. The recent widespread use of multiprocessor hardware exposed OO's Achilles heel: distributed hidden states mutated by multiple uncoordinated threads lead to chaos. Due to their tractable, mathematical nature, FP's functions are the ideal organising mechanism for modern, large, complex, multithreaded programmes. In the rest of this article, I explore this theme in detail.

Although FP is a hot topic in the software industry at present, this popularity has not been a constant through the years. Indeed, it appears to have waxed and waned on a decennial cycle:

- 1960s (FP)—Modern, high-level programming languages emerged in the late 1950s. By the 1960s, LISP has firmly established itself as the language for rule-based AI. LISP influenced [Landen](https://en.wikipedia.org/wiki/Peter_Landin)'s [ISWIM](https://en.wikipedia.org/wiki/ISWIM), which in turn influenced ML. ML is the progenitor of all modern functional languages, including Standard ML, OCaml, Coq, F#, Reason, Haskell, Agda, Idris, and many others.
- 1970s (PP)—C, Pascal, and other procedural programming (PP) languages were the rage, and LISP receded into the background.
- 1980s (FP)—Scheme (a LISP dialect) and Common LISP (standardised LISP) were dominant in the industry during this decade and ML in academia. This upswing of interest in FP was brought about by the hype of rule-based AI.
- 1990s (OO)—C++, Java, Python, Ruby, and other object-oriented (OO) languages define this decade. OO languages also gave birth to web servers, web browsers, and early web applications.
- 2000s (FP)—This decade saw the rise in popularity of Standard ML, OCaml, and Haskell in academia. These languages were also used in actuarial and financial application domains where algorithmic correctness and type safety are paramount.
- 2010s (OO)—JavaScript was an unused and unloved OO language from the 1990s. It was designed to perform light scripting work inside web browsers. Then in the 2010s, Google's V8 engine and server-side Node implementation turned JavaScript into the definitive web development language.
- 2020s (FP)—JavaScript saturation of 2010s gave way to JavaScript fatigue of the 2020s. This fatigue gave rise to a slew of modern, industrial-strength web and mobile development languages which are inherently OO, but are also armed with powerful FP facilities.

# PRESENT

In OO, an object neatly encapsulates state and behaviour of a component. When the component interacts with other components in the application, its methods mutate its hidden internal state. The application's aggregate state, therefore, is divided up into small pieces that are hidden away inside disparate cocoons that jealously guard their respective hidden state. OO's encapsulation mechanism enables the programmer naturally to represent the interaction behaviour of discrete components. But this benefit is offset by OO's hindrance of the programmer's ability easily to represent the application's aggregate state as a composition of the individual component states. On a multiprocessor hardware, uncoordinated component state mutations by multiple threads lead to unpredictable behaviour. In a sense, OO is good at breaking things apart, but not so good at putting things back together.

FP, unlike OO, not only provides excellent means to break things up into pieces in the form of functions, FP also makes composition explicit, natural, and simple. That is, FP gives the programmer an easy way to compose a coherent application out of many independent functions. A function's behaviour is completely determined by its implementation, without any need to coordinate with other functions. Hence, an FP programme runs efficiently on modern parallel processors, and its aggregate behaviour is . In is one of the reasons why FP is gradually gaining interest, if not acceptance, in the industry. In academia, though, FP concept has long been established, dating back to [Church](https://en.wikipedia.org/wiki/Alonzo_Church)'s [λ-calculus](https://en.wikipedia.org/wiki/Lambda_calculus) in the 1930s. The λ-calculus is the mathematical model of computation on which all FP languages are built. [McCarthy](https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist))'s [LISP](https://en.wikipedia.org/wiki/Lisp_(programming_language)) (1958), the second oldest high-level programming language, was influenced by λ-calculus.

Currently popular FP-friendly languages—Scala, F#, Kotlin, Swift, Reason, etc.—use the Hindley-Milner type system. And they all have a garbage collector. This combination of features offers a balance between principle and pragmatism. The trouble, though, is most people coming into these new FP languages are experienced programmers steeped in the OO lore, and as such they tend to write OO programmes in the new FP syntax. This situation is worsened by these languages' built-in OO support. These programmers thus end up paying the cost of adopting a new, unfamiliar FP language, without receiving the full benefits that FP offers.

# PROJECTION

As with everything in IT, it is impossible to predict with accuracy the future of programming language trends beyond a couple of years. But these few things about the current crop of popular languages are certain: JavaScript will continue to dominate business and mobile software development in the near future, perhaps even over the coming decade; the rate at which new languages are being invented will continue to accelerate; almost every new language that comes out during the next decade will likely be an OO-FP hybrid with the Hindley-Milner type system and the C-like syntax. You see, the IT industry is fond of inventing new wheels that are almost as round as the ones that came before.

# PREPARATION

A young programmer can inoculate himself against this perpetual state of tumult by studying the theoretical foundations and a handful of classic programming languages. Theoretical foundations include the following areas of mathematics: logic, discrete structures, type theory, complexity theory, and category theory. Classic programming languages that everyone should know are [C](https://gcc.gnu.org/), [Standard ML](http://smlnj.org/), [Smalltalk](https://squeak.org/), and [Scheme](https://racket-lang.org/). A good CS degree programme covers all these topics, though not necessarily at an adequate level of detail. And given the pace of progress in technology, a computer scientist must continue to study and improve himself throughout his career, in both theory and practice.

## *functional*

Despite FP being a long-established concept in mathematics and in computing, there is no universally accepted definition on what constitutes a [functional programming language](https://en.wikipedia.org/wiki/Functional_programming). Specifically, the term "functional" means a higher-order function that accepts functions as arguments or that returns functions as results. Hence, a functional language must at least support higher-order functions. More generally, a language that treats functions as first-class values is considered a functional language. The phrase "first-class functions" means the language relies on functions are one of the primary means of abstraction; functions can be held in variables as values; functions can be passed to functions as argument values; and functions can be returned from functions as result values. LISP is one such language.

The modern trend is to equip a functional language with a strong, static, structural, inferencing type system, such as the [Hindley-Milner](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system). A [type system](https://en.wikipedia.org/wiki/Type_system) comprises a set of rules that ensure the assignment of a unique type to every language construct: variable, expression, record, function, etc. A *strongly-typed* type system prevents mixing variables of different types in an expression, whereas a weakly-typed type system allows type mixing. A *statically-checked* type system performs type checking at compile-time, while a dynamically-checked type system performs type checking at runtime. A *structural* type system considers two constructs are type compatible if they possess the same shape (structure), whereas a nominal type system requires two constructs to have the same type name for compatibility. An *inferred* type system automatically infers correct types wherever possible during type checking, but a manifest type system requires the programmer to specify types manually.

Nearly all functional languages used in the industry today are impure and strict, but a few advanced functional languages favoured by connoisseurs in academia, like Haskell, Agda, and Idris, are pure and non-strict. In an *impure* functional language, functions are permitted to have side effects, such as mutating global variables or performing I/O. A pure language, on the other hand, forbids side effects, so its functions are tractable and mathematical. A language that employs *strict* (eager) evaluation strategy reduces expressions to values immediately upon first encounter, whereas a language that uses non-strict (lazy) evaluation strategy reduces expressions to values only when necessary, thereby avoiding unnecessary evaluations.

use python and typescript in functional way