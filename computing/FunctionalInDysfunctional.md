---
title: "Being Functional in the Dysfunctional World"
---

# PRELIMINARY

Today, there exists countless new programming languages for every imaginable task. Yet, a vast majority of software development teams use decades-old object-oriented programming languages, like Python, Java, C#, or JavaScript. In simple terms, this strange situation can be attributed to the fact that language choices in the industry are driven by economic realities, instead of by technical capabilities.

The IT industry, for the most part, is made up of small companies run by businessmen. While Silicon Vally giants set technical fashion trends, there are but a few of them in existence. Most IT workers all over the world are employed by smaller entities which are not even technology companies at all. These businesses are run by non-technical, conservative businessmen: technical excellence informs, but does not dictate, their business decisions; profit margins do. Consequently, the IT industry behaves like a murder of crows—cacophonous, boisterous, and assertive individually, but the whole lot nevertheless flies and lands together, watching and emulating one another.

This phenomenon, at least in part, explains JavaScript's inexplicable popularity and the relative obscurity of a more capable language, such as Dart. JavaScript is an easy language to learn to use poorly on a small scale. Dart, though quite similar in look and feel to JavaScript, is a more sophisticated language designed for use by professionals on large projects. As such, it is more difficult to learn. This makes JavaScript popular with novices. Novices are cheap to hire. Profit-driven businessmen favour cheap labourers, not expensive thinkers. Thus, the few who aspire to do their jobs in technically correct ways are nevertheless constrained by the financially expedient decisions, and they must cope with the unexpected, and often undesired, technical consequences that follow those business decisions.

Other than JavaScript, TypeScript and Python are two of the most popular languages in the industry, at present. Both these languages are well established with large user communities. Python is popular in data science and server implementation because of its cogent APIs for numerical computing and system programming. TypeScript is popular in web and mobile development because it is essentially JavaScript with a powerful type system. It is more likely than not that you will be required by your employer to use these languages.

In this article, I explore the functional programming style for thinking and working in TypeScript 4 and Python 3, describing not just syntactic etiquettes but semantic proprieties as well. The target audience is technologists who lead in-house software development teams that use these languages to develop custom, line-of-business applications for small- to medium-sized businesses. By "line-of-business application" I mean specifically the mission-critical software used exclusively by small number of business-expert employees whose primary concern is efficacy, not eye candy. Although these business applications are mundane, they are essential to the running of countless businesses that operate factories, warehouses, freighters, and outlets—the ordinary companies that drive the global economic engine.

# PAST

Every undergraduate computer science (CS) student is taught two theoretical models of computation: [Church](https://en.wikipedia.org/wiki/Alonzo_Church)'s λ-calculus and [Turing](https://en.wikipedia.org/wiki/Alan_Turing)'s a-machine. The two theories are equivalent, and they both originated in the 1930s, [long before the advent](https://en.wikipedia.org/wiki/History_of_computing_hardware) of modern digital computers. In simple terms, [λ-calculus](https://en.wikipedia.org/wiki/Lambda_calculus) models computation as a collection of data passing through a pipeline of mathematical functions, each function producing a transformed version of its input, whereas [a-machine](https://en.wikipedia.org/wiki/Turing_machine) models computation as a collection of data transformed by a sequence of procedures, each procedure mutating the data, in place. That is, λ-calculus leaves historical versions of the computation along the pipeline, but a-machine obliterates the update history of the data. Procedural programming (PP) languages like FORTRAN, C, and Pascal present a high-level view of a-machine. Functional programming (FP) languages like LISP, ML, and Haskell present a high-level view of λ-calculus. But both PP and FP languages compile down to assembly, which is a low-level software representation of hardware computation. Although both FP and PP perform the same computation in hardware, FP is closer to theoretical foundations of CS but PP is closer to practical aspects of hardware. As such, FP appeals to those with a mathematical bent, while PP appeals to those with a mechanical sense.

Computing hardware, no matter how modern, can be reduced to the a-machine model. Computation performed by this type of hardware progresses by executing one by one the operations that mutate a global state. At the start of a computation, the global data is initialised, and when the computation terminates, the result is represented by the final state of the global data. This was how computers worked in the 1940s, and this is still how computers work in the 2020s.

As hardware capabilities grew over time, software complexity increased, commensurately. PP's proximity to hardware is an asset when programming in the small, but it is a liability when developing large, complex software. Object-oriented (OO) paradigm that dominates the software industry today is a better-organised PP—a more sophisticated a-machine. But the more sophisticated organisational techniques that OO offers are indispensable when programming in the large. The `class` mechanism, the central organising principle in OO, hides mutable state inside an object and exposes the object's behaviour through a set of methods. These methods, which are just procedures, are the only way for outsiders to access and mutate the object's internal state. In this way, OO allows the programmer to divide up the application's large, aggregate state into small, manageable states hidden inside individual objects, and computation progresses as the objects interact with one another and update each other's states via mutating methods.

The first OO language is Simula (1962). But it was not until the advent of C++ in the 1980s and Java in the 1990s that made OO a household name. OO's appeal is that it allows the programmer to model directly the real-life concepts and entities—banks, boats, bacteria, whatever—while remaining close to the hardware semantics. Thus, OO, like its PP cousin, appeals to the mechanically minded programmers.

Despite the perennial popularity of OO languages in industry, academic FP languages are making inroads into industry, today. The recent widespread use of multiprocessor hardware exposed OO's Achilles heel: distributed hidden states mutated by multiple uncoordinated threads lead to chaos. Due to their tractable, mathematical nature, FP's functions are the ideal organising mechanism for modern, large, complex, multithreaded programmes. In the rest of this article, I explore this theme in detail.

Although FP is a hot topic in the software industry at present, this popularity has not been a constant through the years. Indeed, it appears to have waxed and waned on a decennial cycle:

- 1960s (FP)—Modern, high-level programming languages emerged in the late 1950s. By the 1960s, LISP has firmly established itself as the language for rule-based AI. LISP influenced [Landen](https://en.wikipedia.org/wiki/Peter_Landin)'s [ISWIM](https://en.wikipedia.org/wiki/ISWIM), which in turn influenced ML. ML is the progenitor of all modern functional languages, including Standard ML, OCaml, Coq, F#, Reason, Haskell, Agda, Idris, and many others.
- 1970s (PP)—C, Pascal, and other procedural programming (PP) languages were the rage, and LISP receded into the background.
- 1980s (FP)—Scheme (a LISP dialect) and Common LISP (standardised LISP) were dominant in the industry during this decade and ML in academia. This upswing of interest in FP was brought about by the hype of rule-based AI.
- 1990s (OO)—C++, Java, Python, Ruby, and other object-oriented (OO) languages define this decade. OO languages also gave birth to web servers, web browsers, and early web applications.
- 2000s (FP)—This decade saw the rise in popularity of Standard ML, OCaml, and Haskell in academia. These languages were also used in actuarial and financial application domains where algorithmic correctness and type safety are paramount.
- 2010s (OO)—JavaScript was an unused and unloved OO language from the 1990s. It was designed to perform light scripting work inside web browsers. Then in the 2010s, Google's V8 engine and server-side Node implementation turned JavaScript into the definitive web development language.
- 2020s (FP)—JavaScript saturation of 2010s gave way to JavaScript fatigue of the 2020s. This fatigue gave rise to a slew of modern, industrial-strength web and mobile development languages which are inherently OO, but are also armed with powerful FP facilities.

# PRESENT

In OO, concepts are represented by objects, and when objects are assembled into an application, they call each other's methods and these methods mutate respective objects' internal states. In FP, concepts are represented by functions, and functions are assembled into an application using higher-order functions that compose functions. To put it succinctly, OO abstracts *mutation*, but FP abstracts *composition*. Let me elaborate.

An OO application's aggregate state is divided up into small pieces that are hidden away inside disparate cocoons that jealously guard their respective hidden state. OO's encapsulation mechanism enables the programmer naturally to represent the interaction behaviour of discrete components. But this benefit is offset by OO's hindrance of the programmer's ability easily to construct the application's aggregate state as a composition of the individual component states. On a multiprocessor hardware, uncoordinated component state mutations by multiple threads lead to chaos. In a sense, OO is good at breaking things apart, but not so good at putting things back together.

FP, unlike OO, not only provides excellent means to break things up into pieces (analysis) by way of functions, FP also makes composition explicit, natural, and simple (synthesis) by way of higher order functions. That is, FP gives the programmer an easy way to compose a coherent application out of many independent functions. A function's behaviour is completely determined by its implementation, without any need to coordinate with other functions. Hence, an FP programme runs efficiently on modern parallel processors, and its aggregate behaviour emerges from multiple parallel threads that collaborate, instead of collide, with one another. This is one of the reasons why FP is gradually gaining interest in the industry. In academia, though, FP's innate mathematical elegance has long been appreciated, dating back to [Church](https://en.wikipedia.org/wiki/Alonzo_Church)'s [λ-calculus](https://en.wikipedia.org/wiki/Lambda_calculus) in the 1930s. The λ-calculus is the mathematical model of computation on which all FP languages are built. [McCarthy](https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist))'s [LISP](https://en.wikipedia.org/wiki/Lisp_(programming_language)) (1958), the second oldest high-level programming language, was influenced by λ-calculus.

Currently popular FP-bent languages—Scala, F#, Kotlin, Swift, Reason, etc.—use strong, static typing and have garbage collector. This combination of features offers a balance between principle and pragmatism. The snag, though, is these languages' built-in OO support. Since most people coming into these new FP languages are experienced programmers steeped in OO myths and lores, they tend to rely on the languages' OO facilities, thereby creating OO programmes in the new FP syntax. Programmers thus pay the cost of adopting a new, unfamiliar FP language, without extracting the full benefits that FP offers.

# PREDICTION

As with everything in IT, it is impossible to predict with accuracy the future of programming language trends beyond a couple of years—if that. But these few things about the near future are certain: OO in general and JavaScript in particular will continue to dominate line-of-business software development and newer FP languages will occupy more specialised areas of software development; out of habit, programmers will continue to use OO design principles, even when they are forced to use FP languages; the rate at which new languages are being invented will continue to accelerate; almost every new language that comes out will be an OO-FP hybrid with the Hindley-Milner type system and the C-like syntax.

You see, the IT industry is fond of inventing new wheels that are almost as round as the ones already in existence. One thing we can be sure of is that, at least for the near future, enterprise programmers will continue to be forced to use established OO languages, like JavaScript, Python, Java, and C#.

# PREPARATION

Although the industry's proclivity to reinvent is pernicious, it does provide stability in a perverse sort of way. The continuous stream of new languages that sprout up may appear radical and different superficially, but they all share the same design philosophies underneath. A young programmer can inoculate himself against this perpetual state of tumult by studying the theoretical foundations and a handful of classic programming languages.

Theoretical foundations include the following areas of mathematics: logic, discrete structures, type theory, complexity theory, and category theory. CS curricula from reputable universities cover these topics, adequately. But CS curricula vary in their emphasis on programming languages, most opting to teach only the few languages currently popular in the industry, such as Java, C#, Python, or JavaScript. That is a grave mistake. All CS students should be exposed to the following classic programming languages, at a minimum: [C](https://gcc.gnu.org/), [Standard ML](http://smlnj.org/), [Smalltalk](https://squeak.org/), and [Scheme](https://racket-lang.org/).

After more than five decades, C is still the front-line systems programming language in the industry, because it is a high-level language that manages to remain close to hardware. Standard ML, in terms of both syntax and semantic, has been the mother of all FP languages that came about over the past five decades, like OCaml, F#, and Reason. Smalltalk, the first pure-OO language, is the spiritual ancestor of all OO languages that emerged during the past five decades, such as Objective-C, Ruby, Java, and Swift. Scheme (Racket), along with Clojure, are descendants of LISP, the world's second oldest high-level language and the first FP language. LISP can easily be learned by children, and it can effectively be used by professionals. This language has survived for over six decades, mainly due to this versatility.

By being exposed to the diverse philosophies and approaches behind the designs of these classic languages, one is well-prepared to take up any new language, because every so-called "new" language that has come to prominence over the past forty or so years is a derivative of these classic languages.

## *functional*

Despite FP being a long-established concept in mathematics and in computing, there is no universally accepted definition on what constitutes a [functional programming language](https://en.wikipedia.org/wiki/Functional_programming). Specifically, the term "functional" means a higher-order function that manipulates functions, one that accepts functions as arguments or returns functions as results. Hence, a functional language, by this very label, must at least support higher-order functions. More generally, a language that treats functions as first-class values is considered a functional language. The phrase "first-class functions" means the following: the language relies on functions as one of the primary means of abstraction, functions can be held in variables as values, functions can be passed to functions as argument values, and functions can be returned from functions as result values. LISP ably meets these minimal requirements for FP languages.

FP languages can be categorised by their type checking strategies and expression evaluation strategies. The *typing* strategy choices are strong v. weak, static v. dynamic, structural v. nominal, and inferred v. manifest. The *evaluation* strategy choices are impure v. pure, and strict v. non-strict.

***typing***—The modern trend is to equip a functional language with a strong, static, structural, inferencing type system, such as the [Hindley-Milner](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system). A [type system](https://en.wikipedia.org/wiki/Type_system) comprises a set of rules that ensure the assignment of a unique type to every language construct: variable, expression, record, function, etc.

A *strongly-typed* type system prevents mixing variables of different types in an expression, whereas a *weakly-typed* type system allows some level of type mixing, such as automatically promoting `int` to `double` in a mixed expression or automatically converting `float` to `string` when printing the value.

A *statically-checked* type system performs type checking at compile-time, while a *dynamically-checked* type system performs type checking at runtime.

A *structural* type system considers two pieces of data are type compatible if they occupy the same shape in memory, whereas a *nominal* type system requires data types to be of the same name for type compatibility.

An *inferred* type system automatically infers correct types of expressions wherever possible during type checking, but a *manifest* type system requires the programmer to specify the types of expressions manually.

***evaluation***—Nearly all functional languages used in the industry today are impure and strict, but a few advanced functional languages favoured by connoisseurs in academia, like Haskell, Agda, and Idris, are pure and non-strict.

In an *impure* functional language, functions are permitted to have side effects, such as mutating global variables or performing I/O. A *pure* language, on the other hand, forbids side effects, so its functions are tractable and mathematical.

A language that employs *strict* (eager) evaluation strategy reduces expressions to values immediately upon first encounter, whereas a language that uses *non-strict* (lazy) evaluation strategy reduces expressions to values only when necessary, thereby avoiding unnecessary evaluations.

## ***dysfunctional***

The imperative approach, typified by PP and OO languages, has powered the IT industry for more than sixty years, and it is still thriving. But the recent explosion of complexity in both business operations and supporting technologies has exposed the inherent weaknesses of the imperative approach.

Despite the fact that new FP languages are spawning faster than a population of rabbits, OO languages are still the mainstay in the industry. Given the conservative nature of businesses, programmers in the enterprise software development line of work will not be permitted to use anything but an established OO language. For the moment, two rather old OO languages, JavaScript and Python rule—some might say, ruin—all aspects of line-of-business programmers' lives.

The original versions of JavaScript and Python employ weak, dynamic, structural typing and impure, strict evaluation. This combination of characteristics made these languages easy to use, because they did away with ceremonial incantations associated with statically typed, compiled languages that were popular some three decades ago. This made these languages attractive for small, quick-and-dirty projects. Their modern descendants, TypeScript 4 and Python 3, are mature languages armed with enterprise-scale features, yet without sacrificing the ease-of-use.

TypeScript 4 uses strong, static, structural, inferred type system and impure, strict evaluation strategy. Statically typed TypeScript programmes are compiled into dynamically typed JavaScript programmes that run on a JavaScript virtual machine. On the other hand, Python 3 layers a manifest type hints atop classic Python's weak, dynamic, nominal type system. Python programmes typically run on a Python interpreter, but they too can be compiled into JavaScript. These languages have sophisticated FP and module facilities. Yet, they retain those ease-of-use characteristics that made their predecessors popular with programmers. In other words, TypeScript 4 and Python 3 are FP programmers' best friends in the fast-paced, large-scale enterprise software development where OO still reigns, because despite being decidedly OO, these languages provide many useful FP facilities.

# PRESENT

use ts4 py3 in fp way

