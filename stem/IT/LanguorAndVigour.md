---
title: "Displacing Languor with Vigour in IT"
tags:
  - mathjax
use_math: true
---

[TOC]

# INTRODUCTION

In the early 1950s, [computers first became available](https://en.wikipedia.org/wiki/UNIVAC) commercially. That marked the birth of IT, an offspring of business management, whose family duty was to collect, cleanse, and curate operational information and extract business intelligence therefrom. Although the reach and impact of IT has now spread to every facet of humanity, enterprise computing remains its primary domain.

The goal of IT is to automate laborious, error prone manual tasks, thereby decreasing cost and increasing efficiency of business operations. But as with all human endeavours, every benefit in IT has attendant costs. It is the IT managers' responsibility to tip the balance toward benefits. As technology advances, it allows the practitioners to think more abstractly and to solve more complex problems. That is good. But in due course, actions became abstract and solutions became complex. That is bad.

Simple, daily tasks in computing are now performed with large, open-source packages filled with bloat. Countless layers of external dependencies that no one fully understands have buried the few internally developed components that are essential to operational success. Untested rapid prototypes are habitually deemed to be production ready. IT has lost the battle for efficiency and simplicity, and practitioners can no longer comprehend the massive, long-lived systems they inherited. In some ways, managing the IT solutions has now become a massive business problem, in itself.

In this article, I analyse a list of ailments that plague modern IT products, projects, processes, and people in enterprise software development, and describe potential cures for the pandemic of cost and complexity that ails the industry. At present, the IT industry does not possess effective remedies for these ailments; nevertheless, it is beneficial to document them, comment upon them, learn from them, and formulate cures for them, so that we may, at least, begin contemplating palliatives.

Note that the technological alternatives I present below are directed at IT systems designed to solve internal, operational problems of the enterprise. Although the specific suggestions do not apply directly to external, public-facing systems, the core principles of agility and simplicity do apply to all IT systems, generally.

# MANAGEMENT

mismanagement and misallocation of resources

## *planning*

Little or no planning

Lack of plan leads to fiddling: tweaking code instead of refining design

## *time*

Not enough time

Everybody is coding in one way or another. e.g., CPAs and CFAs are coding in SQL to get something done

Mangers are always rushing their teams

Nobody is training anybody anything

“Sunk-cost fallacy” - can’t touch this system. Keep adding features onto this bloated legacy system

Nobody is thinking about understanding what the system is supposed to do. Just following marching orders to keep adding features and maintaining

## *budget*

Inappropriate allocation of budget due to poor understanding of needs and lack of planning

## *personnel*

No time or money to train the staff

staff is fungible to management

there is no organised network—like IEEE or ABA—so IT practitioners are at the mercy of headhunters

managed by non-practitioners

# WISDOM

lack of proper resource management led to atrophy of skills, knowledge, and collective wisdom

## *skills*

Not enough technical skills to do the job

Everyone is doing everything without mastering anything and fumbling everything.

Nobody knows anything. Everyone is doing whatever they can to keep their jobs.

## *knowledge*

No formal CS education

No understanding of economical and sociological needs

## *ethics*

No more wise guys

Need to be linked with academia

non-stop search for something new drained out the old wisdom

# COMPLEXITY

lack of institutional wisdom led to uncontrolled complexity

## *choices*

Frameworks, languages, processes, tools

Front-end tools/libraries/frameworks

Server-side languages/frameworks

Identity and Authorization providers and techniques to integrate with (OAuth, SAML, JWT…)

Message queuing infrastructure

☁️ Cloud

DevOps CI/CD and Docker, Kubernetes

Databases and NoSQL

Tableau, Data Bricks, BI, Data Science Analytics

## *complexity*

Overwhelming deliverables & complexity without training anyone to do anything right while not having any purpose in job functionalities and responsibilities

complexity (apparent sophistication) v. simplicity (actual sophistication)

adding small feature requires massive amount of maintenance

## *size*

complexity is directly proportional to size

the modern preference for monolithic designs is wrong

the modern ideal of dissecting a system into micro services is equally wrong

seek UNIX-like balance

# *communication*

$O(n^2)$

# GROWTH

complexity hinders growth

## *publication*

unrefereed publications focusing on tools and techniques dominate; no one is studying maths and CS

## *learning*

No time for self improvement

Certifications issued by unregulated, private organisations after a week-long remedial course are no substitute for sustained, formal study in CS

don't be a one-trick pony: learn C, Scheme, Smalltalk, SML

there is no end to learning: learning one thing leads to knowing how many more things one needs to learn; the more you learn, the more you know how little you actually know

## *innovation*

No genuine innovation due to wallowing in complexity

Just rehashings

# SATISFACTION

lack of growth led to dissatisfaction

## *motivation*

unhappy people are unmotivated to do the right thing, and the vicious cycle ensues

## *happiness*

Everyone is unhappy with his lot in life, because everything seems out of control

## *fulfilment*

asdf

# CONCLUSION

IT is a relatively young field and, as such, it possesses few hard-earned lessons. But the Web hoisted IT onto the global stage, prematurely. Hence, IT is currently facing many troubles. It is simplistic to dismiss these troubles as mere growing pains. On the contrary, they are serious, pervasive problems, powerful enough to stunt the field's future growth, if left unchecked. And they are wrapped up in a vicious cycle, bound together by a thread of general discontent. One way to solve these problems is to break this cycle of negativity. For that, we need to adjust the attitude with education, be it formal or informal.

A mechanical engineer may kill a user when his ill designed tool explodes. A civil engineer may kill tens of commuters when his poorly designed bridge collapses during rush hour. An aerospace engineer may kill hundreds of passengers when his badly designed wing falls off an airplane in flight. These licensed professionals suffer the consequences of their malpractice. But programmers do not.

This is because programming is not engineering and programmers are not licensed professionals whose education and performance are subject to oversight by the state. It is a universally accepted truth that no large programme is ever free of bugs. And there is no objective way to determine whether a software bug is caused by mal-intent, recklessness, negligence, or chance. Indeed, there is no reliable, definitive way to attribute a bug to an individual programmer. So, it is impossible to apportion blame when a large, complex piece of enterprise software crashes and causes massive losses of profits and property.
